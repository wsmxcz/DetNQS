# File: lever/dtypes.py
# Unified data structures for the LEVER workflow.

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, NamedTuple, Callable

import flax.struct
import jax.numpy as jnp
import numpy as np
from numpy.typing import NDArray

from .config import ComputeMode

# ============================================================================
# Type Aliases
# ============================================================================

PyTree = Any

# Sparse matrix-vector product; concrete return type depends on mode
SpMVFn = Callable[[jnp.ndarray, ...], Any] # type: ignore

# log(ψ) evaluator θ → log ψ[nsamples]
LogPsiFn = Callable[[PyTree], jnp.ndarray]

OptimizerState = Any
JVPFn = Callable[[PyTree], jnp.ndarray]        # Jacobian-vector product
VJPFn = Callable[[jnp.ndarray], tuple[PyTree]] # Vector-Jacobian product

# ============================================================================
# Primitives (Physical & Mathematical)
# ============================================================================

@dataclass(frozen=True)
class COOMatrix:
    """
    Sparse matrix in COOrdinate format.

    Format: H[rows[i], cols[i]] = vals[i]
    """
    rows: NDArray[np.int32]
    cols: NDArray[np.int32]
    vals: NDArray[np.float64]
    shape: tuple[int, int]

    @property
    def nnz(self) -> int:
        """Number of non-zero elements."""
        return self.vals.size


@dataclass(frozen=True)
class SpaceRep:
    """
    Hilbert space partition: S (selected) ∪ C (complement).

    Determinants: uint64 pairs [α-string, β-string]
    H_diag: Precomputed diagonal elements
    """
    s_dets: NDArray[np.uint64]
    c_dets: NDArray[np.uint64]
    h_diag_s: NDArray[np.float64]
    h_diag_c: NDArray[np.float64]

    @property
    def n_s(self) -> int:
        """Dimension of S-space."""
        return self.s_dets.shape[0]

    @property
    def n_c(self) -> int:
        """Dimension of C-space."""
        return self.c_dets.shape[0]


# ============================================================================
# Log-psi evaluation helper
# ============================================================================

@dataclass(frozen=True)
class LogPsiEval:
    """
    Unified interface for log(ψ) evaluation.

    - eval_s:    log ψ on S-space only (optional for full-space modes)
    - eval_full: log ψ on concatenated S ∪ C space
    """
    mode: ComputeMode
    eval_s: Callable[[PyTree, jnp.ndarray], jnp.ndarray] | None
    eval_full: Callable[[PyTree, jnp.ndarray, jnp.ndarray], jnp.ndarray]

    def for_tape(self, feat_s: jnp.ndarray, feat_c: jnp.ndarray) -> LogPsiFn:
        """
        Build a parameter-only logψ(θ) for the geometry tape.

        EFFECTIVE / ASYMMETRIC:
            use S-space view for normalization.
        PROXY:
            use full T-space wavefunction.
        """
        if self.mode in (ComputeMode.EFFECTIVE, ComputeMode.ASYMMETRIC) and self.eval_s is not None:
            return lambda params: self.eval_s(params, feat_s)
        # Default: use full-space view
        return lambda params: self.eval_full(params, feat_s, feat_c)


# ============================================================================
# Workflow Types (Outer & Inner Loop Management)
# ============================================================================

@dataclass(frozen=True)
class OuterState:
    """
    Persistent state evolving across outer loop cycles.

    Tracks current search space and optimized parameters.
    """
    cycle: int
    s_dets: np.ndarray
    params: PyTree
    e_ref: float | None


@dataclass(frozen=True)
class OuterCtx:
    """
    Read-only context for a single outer loop cycle.

    Generated by engine.context.build_context, consumed by inner solver
    and evolution strategy.
    """
    # Physical system
    space: SpaceRep
    ham_ss: COOMatrix
    ham_sc: COOMatrix
    e_nuc: float

    # Neural network features
    features_s: jnp.ndarray
    features_c: jnp.ndarray

    # Compiled operators (closures with captured data)
    log_psi: LogPsiEval
    spmv_fn: Any

    # Computation metadata
    compute_mode: ComputeMode


@flax.struct.dataclass
class InnerState:
    """
    JIT-compatible state for inner optimization loop.

    Updated at each gradient descent step.
    """
    params: PyTree
    opt_state: PyTree
    step: int = 0


@dataclass(frozen=True)
class InnerResult:
    """
    Complete inner loop output.

    Contains optimized parameters and convergence diagnostics.
    """
    final_params: PyTree
    energy_trace: list[float]
    psi_cache: "PsiCache"
    converged: bool
    steps: int


@dataclass(frozen=True)
class LeverResult:
    """
    Final LEVER calculation result.

    Returned to user with parameters and convergence history.
    """
    final_params: PyTree
    final_s_dets: np.ndarray

    # Convergence history
    full_energy_history: list[float]
    cycle_boundaries: list[int]

    total_time: float
    config: Any

    final_space: SpaceRep | None = None
    final_psi_cache: "PsiCache | None" = None  # type: ignore[assignment]


# ============================================================================
# Engine Types (JAX Computations & Intermediate Results)
# ============================================================================

@flax.struct.dataclass
class PsiCache:
    """
    Wavefunction snapshot after inner loop convergence.

    Stores log-amplitudes and normalized amplitudes for S and C spaces.
    """
    log_psi_all: jnp.ndarray
    psi_all: jnp.ndarray
    n_s: int = flax.struct.field(pytree_node=False)

    @property
    def psi_s(self) -> jnp.ndarray:
        """S-space amplitudes."""
        return self.psi_all[:self.n_s]

    @property
    def psi_c(self) -> jnp.ndarray:
        """C-space amplitudes."""
        return self.psi_all[self.n_s:]


@flax.struct.dataclass
class GeometryTape:
    """
    Quantum geometric tensor (QGT) computation context.

    Captures linearization of log(ψ) for efficient gradient computations.
    """
    jvp_fn: Any = flax.struct.field(pytree_node=False)
    vjp_fn: Any = flax.struct.field(pytree_node=False)
    log_psi: jnp.ndarray
    weights: jnp.ndarray
    centered_mean: PyTree


@flax.struct.dataclass
class Contractions:
    """
    Block-wise Hamiltonian-wavefunction products: n_{ij} = Σ_k H_{ik}·ψ_k.

    Notation: n_ss = H_{SS}·ψ_S, n_sc = H_{SC}·ψ_C, etc.
    C-space blocks optional for effective-space mode.
    """
    n_ss: jnp.ndarray
    n_sc: jnp.ndarray | None = None
    n_cs: jnp.ndarray | None = None
    n_cc: jnp.ndarray | None = None


class GradResult(NamedTuple):
    """Energy and gradient calculation output."""
    grad: PyTree
    energy: jnp.ndarray


class ScoreResult(NamedTuple):
    """Determinant scoring output for space evolution."""
    scores: np.ndarray
    dets: np.ndarray
    meta: dict


# ============================================================================
# Public API
# ============================================================================

__all__ = [
    # Type Aliases
    "PyTree",

    # Primitives
    "COOMatrix",
    "SpaceRep",

    # Log-psi helper
    "LogPsiEval",

    # Workflow Types
    "OuterState",
    "OuterCtx",
    "InnerState",
    "InnerResult",
    "LeverResult",

    # Engine Types
    "PsiCache",
    "GeometryTape",
    "Contractions",
    "GradResult",
    "ScoreResult",
]