# Copyright 2025 The LEVER Authors - All rights reserved.
# SPDX-License-Identifier: Apache-2.0

"""
Unified data structures for the LEVER workflow.

Defines a clear hierarchy of immutable data containers organized by their role:
- Primitives: Foundational physical and mathematical objects
- Workflow Types: High-level containers for outer and inner loops
- Engine Types: Low-level containers for JAX computations

File: lever/dtypes.py
Author: Zheng (Alex) Che, email: wsmxcz@gmail.com
Date: November, 2025
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, NamedTuple, Callable

import flax.struct
import jax.numpy as jnp
import numpy as np
from numpy.typing import NDArray

from .config import ComputeMode

# ============================================================================
# Type Aliases
# ============================================================================

PyTree = Any
SpMVFn = Callable[[jnp.ndarray, ...], tuple[jnp.ndarray, ...]]  # type: ignore
LogPsiFn = Callable[[PyTree], jnp.ndarray]
OptimizerState = Any
JVPFn = Callable[[PyTree], jnp.ndarray]
VJPFn = Callable[[jnp.ndarray], tuple[PyTree]]

# ============================================================================
# Primitives (Physical & Mathematical)
# ============================================================================

@dataclass(frozen=True)
class COOMatrix:
    """
    Sparse matrix in Coordinate (COO) format.
    
    CPU-resident structure for Hamiltonian construction and Numba kernels.
    Format: (rows[i], cols[i], vals[i]) defines matrix element H[rows[i], cols[i]].
    """
    rows: NDArray[np.int32]
    cols: NDArray[np.int32]
    vals: NDArray[np.float64]
    shape: tuple[int, int]

    @property
    def nnz(self) -> int:
        """Number of non-zero elements."""
        return self.vals.size


@dataclass(frozen=True)
class SpaceRep:
    """
    Hilbert space partition: S (selected) ∪ C (complement).
    
    Contains determinant basis and precomputed diagonal Hamiltonian elements.
    Determinants stored as uint64 pairs [α-string, β-string].
    """
    s_dets: NDArray[np.uint64]
    c_dets: NDArray[np.uint64]
    h_diag_s: NDArray[np.float64]
    h_diag_c: NDArray[np.float64]

    @property
    def n_s(self) -> int:
        """Dimension of S-space."""
        return self.s_dets.shape[0]

    @property
    def n_c(self) -> int:
        """Dimension of C-space."""
        return self.c_dets.shape[0]


# ============================================================================
# Workflow Types (Outer & Inner Loop Management)
# ============================================================================

@dataclass(frozen=True)
class OuterState:
    """
    Persistent state evolving across outer loop cycles.
    
    Core state managed by Driver across evolutionary iterations.
    Represents the current search space and optimized parameters.
    """
    cycle: int
    s_dets: np.ndarray
    params: PyTree
    e_ref: float | None


@dataclass(frozen=True)
class OuterCtx:
    """
    Read-only context for a single outer loop cycle.
    
    Generated by Compiler from OuterState. Provides all necessary
    information for Fitter, Evolver, and Engine without mutation.
    """
    # Physical system
    space: SpaceRep
    ham_ss: COOMatrix
    ham_sc: COOMatrix
    e_nuc: float
    
    # Neural network features (JAX arrays)
    features_s: jnp.ndarray
    features_c: jnp.ndarray

    # Compiled JAX operators (closures with captured data)
    log_psi_fn: Any  # Callable[[PyTree], jnp.ndarray]
    spmv_fn: Any     # Callable[[jnp.ndarray, ...], tuple]
    
    # Computation metadata
    compute_mode: ComputeMode


@flax.struct.dataclass
class InnerState:
    """
    JIT-compatible state for inner optimization loop.
    
    Encapsulates trainable parameters and optimizer state.
    Updated at each gradient descent step by Fitter.
    """
    params: PyTree
    opt_state: PyTree  # Optimizer internals (e.g., Adam moments)
    step: int = 0


@dataclass(frozen=True)
class InnerResult:
    """
    Output of complete inner loop execution.
    
    Contains optimized parameters, energy trajectory, and cached
    wavefunction after convergence.
    """
    final_params: PyTree
    energy_trace: list[float]
    psi_cache: "PsiCache"
    converged: bool
    steps: int


@dataclass(frozen=True)
class LeverResult:
    """
    Final result of complete LEVER calculation.
    
    Returned to user with optimized parameters, convergence history,
    and diagnostic energies.
    """
    final_params: PyTree
    final_s_dets: np.ndarray
    
    # Convergence history
    full_energy_history: list[float]
    cycle_boundaries: list[int]
    
    # Cycle-level diagnostics
    var_energy_history: list[float]
    s_ci_energy_history: list[float]
    
    total_time: float
    config: Any  # LeverConfig object


# ============================================================================
# Engine Types (JAX Computations & Intermediate Results)
# ============================================================================

@flax.struct.dataclass
class PsiCache:
    """
    Wavefunction snapshot after inner loop convergence.
    
    Contains both log-amplitudes and normalized amplitudes for
    S and C spaces. Used for diagnostics and space evolution.
    """
    log_psi_all: jnp.ndarray
    psi_all: jnp.ndarray
    n_s: int = flax.struct.field(pytree_node=False)

    @property
    def psi_s(self) -> jnp.ndarray:
        """S-space amplitudes."""
        return self.psi_all[:self.n_s]

    @property
    def psi_c(self) -> jnp.ndarray:
        """C-space amplitudes."""
        return self.psi_all[self.n_s:]


@flax.struct.dataclass
class GeometryTape:
    """
    Quantum geometric tensor (QGT) computation context.
    
    Captures linearization of log-wavefunction for efficient
    gradient and natural gradient calculations.
    """
    jvp_fn: Any = flax.struct.field(pytree_node=False)
    vjp_fn: Any = flax.struct.field(pytree_node=False)
    log_psi: jnp.ndarray
    weights: jnp.ndarray
    centered_mean: PyTree

@flax.struct.dataclass
class Contractions:
    """
    Block-wise Hamiltonian-wavefunction products: n_ij = ∑_k H_ik · ψ_k.
    
    Notation: n_ss = H_SS·ψ_S, n_sc = H_SC·ψ_C, etc.
    C-space blocks optional for S-only computations.
    """
    n_ss: jnp.ndarray
    n_sc: jnp.ndarray | None = None
    n_cs: jnp.ndarray | None = None
    n_cc: jnp.ndarray | None = None

class GradResult(NamedTuple):
    """Output of energy and gradient calculation."""
    grad: PyTree
    energy: jnp.ndarray


class ScoreResult(NamedTuple):
    """Output of determinant scoring for space evolution."""
    scores: np.ndarray
    dets: np.ndarray
    meta: dict


# ============================================================================
# Public API
# ============================================================================

__all__ = [
    # Type Aliases
    "PyTree",
    
    # Primitives
    "COOMatrix",
    "SpaceRep",
    
    # Workflow Types
    "OuterState",
    "OuterCtx",
    "InnerState",
    "InnerResult",
    "LeverResult",
    
    # Engine Types
    "PsiCache",
    "GeometryTape",
    "GradResult",
    "ScoreResult",
]
